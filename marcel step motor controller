unit main;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, TeEngine, Series, ExtCtrls, TeeProcs, Chart, SerialNG, Persistant,
  ComCtrls, VclTee.TeeGDIPlus;

CONST     frequency= 168000.0;  {33500; //24H clock frequency,3685000/ number 0f instructions in timer interrupt = 110, thus 3685000/110=33500
                                 timer frequency stm32f4 = 168000, timerprescaler=1000 because real clock = 168 MHz                            }

type
  TMainform = class(TPersistant)
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    Label1: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    Label4: TLabel;
    Label5: TLabel;
    prescalercap: TLabel;
    end_time: TLabel;
    CalcButton: TButton;
    Chart1: TChart;
    Series1: TLineSeries;
    totsteps: TEdit;
    testbut: TButton;
    log: TMemo;
    stepbut: TButton;
    Direction: TRadioGroup;
    stepper: TRadioGroup;
    enabler: TCheckBox;
    se: TSerialPortNG;
    Timer1: TTimer;
    TabSheet2: TTabSheet;
    Panel2: TPanel;
    ProgramIcon: TImage;
    ProductName: TLabel;
    Version: TLabel;
    Copyright: TLabel;
    Memo1: TMemo;
    TabSheet3: TTabSheet;
    TabSheet4: TTabSheet;
    serialsettings: TButton;
    Homingbut: TButton;
    stopbut: TButton;
    Label8: TLabel;
    Omega_acclabel: TLabel;
    linear_acclabel: TLabel;
    command_but: TButton;
    StepMotorPageControl: TPageControl;
    TabSheet5: TTabSheet;
    encoder1: TCheckBox;
    lead: TLabel;
    lead_edit1: TEdit;
    encoderset1: TGroupBox;
    encoder_steps_per_RPM: TLabel;
    Label7: TLabel;
    onspeededit1: TEdit;
    Label6: TLabel;
    RPMedit1: TEdit;
    Label10: TLabel;
    Steps_per_RPM1: TEdit;
    encoder_steps_RPM1: TEdit;
    Label9: TLabel;
    max_allowed_miss1: TEdit;
    SaveButton: TButton;
    TabSheet6: TTabSheet;
    Label11: TLabel;
    RPMEdit2: TEdit;
    OnSpeedEdit2: TEdit;
    Label12: TLabel;
    Label13: TLabel;
    lead_edit2: TEdit;
    Steps_per_RPM2: TEdit;
    Label14: TLabel;
    encoder2: TCheckBox;
    encoderset2: TGroupBox;
    Label15: TLabel;
    Label16: TLabel;
    Encoder_steps_RPM2: TEdit;
    Max_allowed_miss2: TEdit;
    TabSheet7: TTabSheet;
    Label17: TLabel;
    RPMEdit3: TEdit;
    Label18: TLabel;
    OnspeedEdit3: TEdit;
    Label19: TLabel;
    lead_edit3: TEdit;
    Label20: TLabel;
    Steps_per_RPM3: TEdit;
    encoder3: TCheckBox;
    encoderset3: TGroupBox;
    Label21: TLabel;
    Label22: TLabel;
    encoder_steps_RPM3: TEdit;
    max_allowed_miss3: TEdit;
    TabSheet8: TTabSheet;
    Label23: TLabel;
    RPMEdit4: TEdit;
    Label24: TLabel;
    OnspeedEdit4: TEdit;
    Lead_edit4: TEdit;
    Label25: TLabel;
    Label26: TLabel;
    Steps_per_RPM4: TEdit;
    encoder4: TCheckBox;
    encoderset4: TGroupBox;
    Label27: TLabel;
    Label28: TLabel;
    Encoder_steps_RPM4: TEdit;
    Max_allowed_miss4: TEdit;
    posdir4: TRadioGroup;
    posdir3: TRadioGroup;
    posdir2: TRadioGroup;
    posdir1: TRadioGroup;
    procedure CalcButtonClick(Sender: TObject);
    procedure testbutClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure serialsettingsClick(Sender: TObject);
    procedure seRxClusterEvent(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure stepbutClick(Sender: TObject);
    procedure enablerClick(Sender: TObject);
    procedure HomingbutClick(Sender: TObject);
    procedure stopbutClick(Sender: TObject);
    procedure command_butClick(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure encoder1Click(Sender: TObject);
    procedure SaveButtonClick(Sender: TObject);
    procedure encoder2Click(Sender: TObject);
    procedure encoder3Click(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure encoder4Click(Sender: TObject);
  private
    { Private declarations }
    decel_steps,
    p_commands,
    encoder_steps_RPM,
    max_allowed_miss,
    steps_per_rpm : integer;
    Lead_acc: double;

    in_timer,
    use_encoder,
    kick_in_timer : boolean;
    all_received_string : String;
    kick_in,
    received_string : String;
    start_time : TDatetime;

    onspeed,              // time to reach rpm. in seconds.
    rpm : double;                  //revolutions per minute, max speed
    function wait_receive_int(aid,aint : integer): boolean;
    function wait_receive_float(aid:integer;afloat: double): boolean;
    function wait_receive(aid: integer;astring: string): boolean;

    procedure AddHexString(S : String);
    function check_pending(pending_commands, id_s: String): integer;
    function check_stopswitch: boolean;
    procedure get_step_settings(index:integer);
    procedure ConfiguraRegiaoBR;
    function homing_direction(cur_dir:integer) : integer;
  public
    { Public declarations }
    procedure Toothsend(kulstr: string;clearstring,waitchar: boolean);
    function wait_receive_char(astring: string;check_stop_button: boolean): boolean;
  end;

var
  Mainform: TMainform;

implementation

{$R *.dfm}
uses math, SerialNGBasic, dateUtils,fixedPmathu;


procedure Tmainform.get_step_settings(index:integer);
VAR AEdit : TEdit;
    Acheck : TCheckbox;

begin
AEdit := TEdit(findcomponent('Steps_per_RPM'+ inttostr(index)));
steps_per_rpm := strtoint(AEdit.text);
AEdit := TEdit(findcomponent('onspeededit'+ inttostr(index)));
onspeed := strtofloat(AEdit.Text);
AEdit := TEdit(findcomponent('RPMedit'+ inttostr(index)));
RPM := strtoint(Aedit.text);
AEdit := TEdit(findcomponent('lead_edit'+ inttostr(index)));
lead_acc := strtofloat(Aedit.text);

end;



function TMainform.wait_receive_int(aid, aint : integer): boolean;
VAR ctime : TDatetime;
    not_in_time : boolean;
begin
  ctime := now;
  Result := false;
  repeat
     application.processmessages;
     not_in_time := MilliSecondsBetween(now,ctime)>1000;
  until (pos (inttostr(aid) + ':' + inttostr(aint), all_received_string) > 0) or not_in_time;
  if not_in_time then
  begin
     log.lines.add('Expecting: ' + inttostr(aid) + ':' + inttostr(aint) + ' failed received string: ' + all_received_string);
     raise Exception.Create('Serial port did not respond within 5 seconds to receive string: '+ inttostr(aint))
  end
  else log.lines.add('In time, received: ' + inttostr(aint));
  Result := true;
end;

function TMainform.wait_receive(aid : integer;astring: string): boolean;
VAR ctime : TDatetime;
    not_in_time : boolean;
begin
  ctime := now;
  Result := false;
  repeat
     application.processmessages;
     not_in_time := MilliSecondsBetween(now,ctime)>1000;
  until (pos (inttostr(aid) + ':' + astring, all_received_string) > 0) or not_in_time;
  if not_in_time then
  begin
     log.lines.add('Expecting : ' + inttostr(aid) + ':' + astring + ' failed received string: ' + all_received_string);
     raise Exception.Create('Serial port did not respond within 1 second to receive string: '+ astring)
  end
  else log.lines.add('In time, received: ' + astring);
  Result := true;
end;

function TMainform.wait_receive_char(astring: string;check_stop_button: boolean): boolean;
VAR ctime : TDatetime;
    not_in_time,gul : boolean;
begin
  ctime := now;
  Result := false;
  if astring = '>' then
  begin
    Result := true;
    exit;
  end;
  repeat
     gul := pos (astring, all_received_string) > 0;
     if not gul then
       application.processmessages;
     not_in_time := MilliSecondsBetween(now,ctime)>1000;
  until gul or not_in_time or (check_stop_button and not stopbut.enabled) ;
  if not_in_time and not (check_stop_button and not stopbut.enabled) then
  begin
     if not_in_time then
          log.lines.add('Time_out!, Expecting: ' + astring + ' failed received string: ' + all_received_string)
     else
       log.lines.add('Expecting: ' + astring + ' failed received string: ' + all_received_string);
     raise Exception.Create('Serial port did not respond within 1 seconds to receive string: '+ astring);
  end
  else log.lines.add('In time, received: ' + astring);

  Result := true;
end;



function TMainform.wait_receive_float(aid:integer;afloat: double): boolean;
VAR ctime : TDatetime;
    not_in_time, found_del, foundfloat : boolean;
    float_string : string;
    start_pos,index : integer;
begin
  ctime := now;
  Result := false;
  float_string := '';
  foundfloat := false;

  repeat
     application.processmessages;
     not_in_time := MilliSecondsBetween(now,ctime)>1000;
     start_pos := pos(inttostr(aid) + ':',all_received_string);
     if start_pos > 0 then
     begin
        found_del := false;
        float_string := '';
        for index := start_pos + 1 to length(all_received_string) do
        begin
           if all_received_string[index] = '>' then
           begin
              foundfloat := strtofloat(float_string) - afloat < 0.000001;
              break;
           end;
           if found_del then
              float_string := float_string + all_received_string[index];
           if all_received_string[index] = ':' then
              found_del := true;
        end;
     end;
  until foundfloat or not_in_time;
  if not_in_time then
  begin
     log.lines.add('Expecting: ' + inttostr(aid) + ':' + floattostr(afloat)+' failed received string: ' + all_received_string);
     raise Exception.Create('Serial port did not respond within 5 seconds to receive float: '+ floattostr(afloat))
  end
  else log.lines.add('In time, received: ' + floattostr(afloat));
  Result := true;
end;

procedure TMainform.Toothsend(kulstr: string; clearstring,waitchar: boolean);
var index : integer;
    achar: Ansichar;
    astr : AnsiString;
begin
//  se.SendString(astr);
//  exit;
  astr := Ansistring(kulstr);
  if waitchar then
      for index := 1 to length(astr) do
      begin
         achar := astr[index];
         if clearstring then all_received_string := '';
         se.SendAnsiString(ansistring(achar));
         if waitchar then wait_receive_char(achar, not clearstring);
      end
  else
      begin
         if clearstring then all_received_string := '';
         se.SendAnsiString(astr);
      end;
end;



procedure TMainform.testbutClick(Sender: TObject);
VAR resp : string;
    index,
    cn_value,
    thedir,
    total_steps_int,
    prescaler: integer;
    alpha,               // motor step angle.
    omega_acc,
    omega_max
    : double;           // timer frequency
begin
   if not Se.Active then
   begin
     log.lines.add('Serial port not activated.');
     raise Exception.Create('Serial port not activated.')
   end;

   try
   get_step_settings(stepper.itemindex+1);

   testbut.enabled := false;


   timer1.Enabled := false;
   omega_max := 2*Pi*rpm/60;

   label1.Caption := 'omega max: ' + floattostr(omega_max);

   omega_acc :=  omega_max/onspeed;

   alpha := 2 * Pi/steps_per_rpm;

  for index := 0 to 7 do
  begin   // check if maximum delay between steps is possibly out of range.
      case index of
        0: prescaler := 1;
        1: prescaler := 2;
        2: prescaler := 4;
        3: prescaler := 8;
        4: prescaler := 16;
        5: prescaler := 32;
        6: prescaler := 64;
        7: prescaler := 128;
      end;
      cn_value := round(0.676*(frequency/prescaler)*sqrt(2*alpha/omega_acc));
      if cn_value < 32760 then
         break
  end;
  prescalercap.caption := 'Prescaler: ' + inttostr(prescaler);


  log.Lines.Clear;
//  Toothsend('a');//start communication
//  wait_receive(1,'rdy'); // pic 24 returns ready when completely programmed

   log.Lines.add('send: ' + '8y');
  Toothsend('<<y'+'8:y'  +inttostr(stepper.itemindex+1)+ '>',true,false);//reset program
  wait_receive(8,'y');

  {all_received_string := '';
  log.Lines.add('send stepper: ' + stepper.items[stepper.itemindex]);
  Toothsend('<c'+inttostr(stepper.itemindex+1) + '>',true,false);//stepper
  wait_receive_int(10,stepper.itemindex+1);  }

  all_received_string := '';
  case stepper.ItemIndex of
     0: thedir := posdir1.ItemIndex;
     1: thedir := posdir2.ItemIndex;
     2: thedir := posdir3.ItemIndex;
     3: thedir := posdir4.ItemIndex;
  end;

  total_steps_int := strtoint(totsteps.Text);
  if total_steps_int < 0 then
     thedir := homing_direction(thedir);
  direction.itemindex := thedir;
  log.Lines.add('send direction: ' + direction.items[direction.itemindex]);
  Toothsend('<v'+inttostr(direction.itemindex) +inttostr(stepper.itemindex+1)+ '>',true,false);//total steps
  wait_receive_int(9,direction.itemindex);

  all_received_string := '';
  log.Lines.add('send total steps: ' + totsteps.Text);
  Toothsend('<s'+inttostr(ABS(total_steps_int)) +inttostr(stepper.itemindex+1) +'>',true,false);//total steps
  wait_receive_int(6,ABS(total_steps_int));

  all_received_string := '';
  log.Lines.add('send steps per rpm: ' + inttostr(steps_per_rpm));
  Toothsend('<p'+inttostr(steps_per_rpm) +inttostr(stepper.itemindex+1)+ '>',true,false);// steps per rpm
  wait_receive_int(5,steps_per_rpm);

  all_received_string := '';
  log.Lines.add('send prescaler: ' + inttostr(prescaler));
  Toothsend('<l'+inttostr(prescaler) + inttostr(stepper.itemindex+1)+'>',true,false);// prescaler
  wait_receive_int(4,prescaler);

  all_received_string := '';
  log.Lines.add('send deceleration steps: ' + inttostr(decel_steps));
  Toothsend('<a'+inttostr(decel_steps) +inttostr(stepper.itemindex+1)+ '>',true,false);// decel_steps
  wait_receive_int(12,decel_steps);

  all_received_string := '';
  log.Lines.add('send rpm: ' + floattostrf(rpm,ffGeneral,15,3	));
  Toothsend('<r'+floattostrf(rpm,ffGeneral,15,3	) +inttostr(stepper.itemindex+1)+ '>',true,false);// max speed
  wait_receive_float(3,rpm);

{  log.Lines.add('enable: ' + stepper.items[stepper.itemindex]);
  Toothsend('<f'+inttostr(stepper.itemindex+1) + '>');//stepper
  wait_receive_int(11,stepper.itemindex+1); not necessary, automatically enabled}

  all_received_string := '';
  log.Lines.add('enable stepper');
  Toothsend('<f1' +inttostr(stepper.itemindex+1)+'>',true,false);//enable
  wait_receive_int(11,1);


  all_received_string := '';
  log.Lines.add('send onspeed: ' + floattostrf(onspeed,ffGeneral,15,3	));
  Toothsend('<o'+floattostrf(onspeed,ffGeneral,15,3	) + inttostr(stepper.itemindex+1)+'>',true,false);// max speed
  wait_receive_float(2,onspeed);
  all_received_string := '';

  all_received_string := '';
  Toothsend('<k'+'FAULT' + inttostr(stepper.itemindex+1)+'>',true,false);// wait for ready
  log.Lines.add('Wait for ready');

  wait_receive(0,'rdy'); // pic 24 returns ready when completely programmed

  start_time := now;
  p_commands := 1;
  timer1.Enabled := true;
  stopbut.enabled := true;
  finally
  testbut.enabled := true;
  end;




end;


procedure TMainform.AddHexString(S : String);
var AddS, HexS, CopyS : String;
    i : Integer;
const SLen = 8;
begin
  while Length(S) > 0 do
    begin
      AddS := Copy(S,1,SLen);
      HexS := '';
      Delete(S,1,SLen);
      for i := 1 to SLen do
        begin
          CopyS := Copy(AddS,i,1);
          if CopyS <> '' then
            HexS := HexS + ' ' + Format('%2.2x',[Byte(CopyS[1])]) //
          else
            HexS := HexS + '   ';
        end;
       while Length(AddS) < SLen do
         AddS := AddS + ' ';
       for i := 1 to SLen do
         case AddS[i] of
           #0..#31 : AddS[i] := '.';
           #127    : AddS[i] := '.';
         end;
//       Lines.Add(HexS+' : '+AddS);
//       Lines.Add(AddS);
       received_string := trim(AddS);
       all_received_string := all_received_string + received_string;
    end;
end;


procedure TMainform.ConfiguraRegiaoBR;
begin
  FormatSettings.DecimalSeparator    := '.';
  FormatSettings.ThousandSeparator   := ',';
  FormatSettings.CurrencyDecimals    := 2;
  FormatSettings.DateSeparator       := '/';
  FormatSettings.ShortDateFormat     := 'dd/mm/yyyy';
  FormatSettings.LongDateFormat      := 'dd/mm/yyyy';
  FormatSettings.TimeSeparator       := ':';
  FormatSettings.TimeAMString        := 'AM';
  FormatSettings.TimePMString        := 'PM';
  FormatSettings.ShortTimeFormat     := 'hh:nn';
  FormatSettings.LongTimeFormat      := 'hh:nn:ss';
  FormatSettings.CurrencyString      := 'â‚¬';
end;

procedure TMainform.FormCreate(Sender: TObject);
begin
  ConfiguraRegiaoBR;
  steps_per_rpm := 1600;
  kick_in_timer := false;
  in_timer := false;
  decel_steps :=  2000;
  rpm := 60;
  onspeed := 1;  //time to be on speed.
  PerIniName := extractfilepath(application.exename) + '\ToothMaster.ini';
  read_ini;
end;

procedure TMainform.serialsettingsClick(Sender: TObject);
begin
  SerialNGBasicDLG.SetDLGData(Se);
  if SerialNGBasicDLG.ShowModal = mrOK then
  begin
    SerialNGBasicDLG.GetDLGData(Se);
    write_ini;
  end;
end;

procedure TMainform.seRxClusterEvent(Sender: TObject);
begin
  if Se.NextClusterSize >= 0 then
    begin
      if Se.NextClusterCCError <> 0 then //error
        log.Lines.Add(FormatDateTime('"Cluster error RecX " dd.mm.yy hh:mm:ss" :"', Now));
      AddHexString(string(Se.ReadNextClusterAsAnsiString));
    end;
end;

function Tmainform.check_pending(pending_commands, id_s: String): integer;
begin
  result := p_commands;
  if (pending_commands <> '') then
             begin
                result := strtoint(pending_commands);
                if result =  9999 then
                   Log.lines.add(id_s + ' : No commands pending, working on final command.')
                else if (result > 0) then
                        Log.lines.add(id_s + ' : Pending commands in buffer: '+ pending_commands)
                else if pos('done',id_s) > 0 then Log.Lines.add('Finished')
                     else Log.lines.add(id_s +' : Finished, probably missed done command');

             end
  else  Log.lines.add(id_s + ' : response without pending commands information, very strange, all_received: ' + all_received_string + ' sub string : ' + pending_commands);
end;

function Tmainform.check_stopswitch: boolean;
// check_stopswitch is true when stopswitch is burning.
VAR index : integer;
    stopsw_str,
    mul : string;
begin
    Result := false;
    for index := 1 to 8 do
          begin
            mul := 'done:' + inttostr(index);
            if pos(mul, all_received_string) > 0 then
            begin
              Result := true;
              p_commands := 0;
              case index of
                   1:stopsw_str := 'stepper 1, left';
                   2:stopsw_str := 'stepper 1, right';
                   3:stopsw_str := 'stepper 2, left';
                   4:stopsw_str := 'stepper 2, right';
                   5:stopsw_str := 'stepper 3, left';
                   6:stopsw_str := 'stepper 3, right';
                   7:stopsw_str := 'stepper 4, left';
                   8:stopsw_str := 'stepper 4, right';
              end;
              Showmessage('Stopswitch error: ' + stopsw_str);
              exit;
            end;
          end;
end;

procedure TMainform.Timer1Timer(Sender: TObject);
var index, startpos, endpos : integer;
    pending_commands,
    mul : string;
begin
try
  timer1.Enabled := false; // otherwise stack forms inside application.processmessages........
  in_timer := true;
  if stopbut.enabled then
  begin
     if kick_in_timer then
     begin
       command_but.enabled := false;
       if check_stopswitch then  //exit, timer will not be set
          exit;
       Toothsend(kick_in,false,false);
       wait_receive(10,kick_in); // pic 24 returns ready when completely programmed
       startpos := pos(kick_in,all_received_string);
         if  startpos > 0 then // check if there are pending commands
         begin
            startpos := startpos + length(kick_in);
            mul := Copy( all_received_string, startpos, length(all_received_string)-startpos+1);   //copy to substring, might be old responses in front.
            endpos := pos(';',mul);
            pending_commands := Copy(mul, 1, endpos-1);
            p_commands := check_pending(pending_commands,'c');
         end;
       if check_stopswitch then  //exit, timer will not be set
          exit
       else all_received_string := '';  // might be that a command just finished before sending command, then there is a pending done in the receive string which has no value because a new command is added.
       kick_in_timer := false;
     end
     else // send either c or w
     begin
       Toothsend('<w'+inttostr(stepper.itemindex+1)+'>',false,false);//watchdog
       wait_receive_char('w',false);
     end;
  end;

  if ( pos ('done:', all_received_string) > 0) then
  begin
     Log.lines.add(all_received_string);
     Log.lines.add('Time passed (sec.): ' + floattostr(MilliSecondsBetween(now,start_time)/1000));
     mul := 'done:0;';
     startpos := pos(mul, all_received_string);
     if  startpos > 0 then  // no stopswitch burning, check for pending commands in buffer.
     begin
         startpos:=startpos+length(mul);
         mul := Copy( all_received_string, startpos, length(all_received_string)-startpos+1);      //copy to substring, might be old responses in front.
         endpos:= pos('>',mul);
         pending_commands := Copy(mul, 1, endpos-1);
         p_commands := check_pending(pending_commands,'done');
     end
     else if check_stopswitch then
             exit;
  end
  else begin // check send w command, might even be that done is missed. in that case polling also stops if no_commands is zero.
         mul := '<w'+inttostr(stepper.itemindex+1)+'>';
         startpos := pos(mul,all_received_string);
         if  startpos > 0 then // check if there are pending commands
         begin
            startpos := startpos + length(mul);
            mul := Copy( all_received_string, startpos, length(all_received_string)-startpos+1);//copy to substring, might be old responses in front.
            endpos:= pos(';',mul);
            pending_commands := Copy(mul, 1, endpos-1);
            p_commands := check_pending(pending_commands,'w');
         end;
       end;
  all_received_string := '';
  in_timer := false;
  command_but.enabled := true;
  if (p_commands > 0) then // continue polling
  begin
      timer1.Enabled := stopbut.enabled; // user could press stop
      if not(stopbut.enabled) then
         Log.lines.add('Stopped by user');
  end
  else
     begin
       stopbut.Enabled := false;
       stepbut.enabled := true;
     end;
except
  all_received_string := '';
  in_timer := false;
  command_but.enabled := true;
end;
end;

procedure TMainform.stepbutClick(Sender: TObject);
begin
  stepbut.enabled := false;
  all_received_string := '';
  log.Lines.add('send total steps: ' + totsteps.Text);
  Toothsend('<q' + totsteps.Text + inttostr(stepper.itemindex+1) + '>',true,false);//total steps
  wait_receive(0,'rdy'); // pic 24 returns ready when completely programmed
  start_time := now;
  stopbut.Enabled := true;
  p_commands := 1;
  timer1.Enabled := true;
end;

procedure TMainform.enablerClick(Sender: TObject);
begin
  log.Lines.add('send direction: ' + direction.items[direction.itemindex]);
  if enabler.checked then
  begin
    Toothsend('<f1' +inttostr(stepper.itemindex+1)+'>',true,false);//enable
    wait_receive_int(11,1);
  end
  else
  begin
    Toothsend('<f0'+inttostr(stepper.itemindex+1)+'>',true,false);//disable
    wait_receive_int(11,0);
  end;
end;

function Tmainform.homing_direction(cur_dir:integer) : integer;
begin
  if cur_dir = 0 then
     Result := 1
  else Result := 0;
end;

procedure TMainform.HomingbutClick(Sender: TObject);
VAR resp : string;
    index,
    cn_value,thedir,
    prescaler: integer;
    alpha,               // motor step angle.
    omega_acc,
    omega_max
    : double;           // timer frequency

begin
   if not Se.Active then
   begin
     log.lines.add('Serial port not activated.');
     raise Exception.Create('Serial port not activated.')
   end;

   try
   CalcButtonClick(Self);
   testbut.enabled := false;


   timer1.Enabled := false;
   omega_max := 2*Pi*rpm/60;

   label1.Caption := 'omega max: ' + floattostr(omega_max);

   omega_acc :=  omega_max/onspeed;

   alpha := 2 * Pi/steps_per_rpm;

  for index := 0 to 7 do
  begin   // check if maximum delay between steps is possibly out of range.
      case index of
        0: prescaler := 1;
        1: prescaler := 2;
        2: prescaler := 4;
        3: prescaler := 8;
        4: prescaler := 16;
        5: prescaler := 32;
        6: prescaler := 64;
        7: prescaler := 128;
      end;
      cn_value := round(0.676*(frequency/prescaler)*sqrt(2*alpha/omega_acc));
      if cn_value < 32760 then
         break
  end;
  prescalercap.caption := 'Prescaler: ' + inttostr(prescaler);



  log.Lines.add('send: ' + '8y');
  Toothsend('<<y'+'8:y'  +inttostr(stepper.itemindex+1)+ '>',true,false);//reset program
  wait_receive(8,'y');

  {log.Lines.add('send stepper: ' + stepper.items[stepper.itemindex]);
  Toothsend('<c'+inttostr(stepper.itemindex+1) + '>',true,false);//stepper
  wait_receive_int(10,stepper.itemindex+1); }

  all_received_string := '';
    case stepper.ItemIndex of
     0: thedir := homing_direction(posdir1.ItemIndex);
     1: thedir := homing_direction(posdir2.ItemIndex);
     2: thedir := homing_direction(posdir3.ItemIndex);
     3: thedir := homing_direction(posdir4.ItemIndex);
  end;
  direction.itemindex := thedir;

  log.Lines.add('Homing send direction: ' + direction.items[direction.itemindex]);
  Toothsend('<v'+inttostr(direction.itemindex) +inttostr(stepper.itemindex+1)+ '>',true,false);//total steps
  wait_receive_int(9,direction.itemindex);

  // thus :
  // - set right direction for homing
  // - call homing selecting the correct stopswitch to use.
  all_received_string := '';
  log.Lines.add('send homing');
  Toothsend('<h1'+inttostr(stepper.itemindex+1)+'>',true,false);//homing
  wait_receive_int(6,1);

  all_received_string := '';
  log.Lines.add('send steps per rpm: ' + inttostr(steps_per_rpm));
  Toothsend('<p'+inttostr(steps_per_rpm) +inttostr(stepper.itemindex+1)+ '>',true,false);// steps per rpm
  wait_receive_int(5,steps_per_rpm);

  all_received_string := '';
  log.Lines.add('send prescaler: ' + inttostr(prescaler));
  Toothsend('<l'+inttostr(prescaler) + inttostr(stepper.itemindex+1)+'>',true,false);// prescaler
  wait_receive_int(4,prescaler);

  all_received_string := '';
  log.Lines.add('send deceleration steps: ' + inttostr(decel_steps));
  Toothsend('<a'+inttostr(decel_steps) +inttostr(stepper.itemindex+1)+ '>',true,false);// decel_steps
  wait_receive_int(12,decel_steps);


  all_received_string := '';
  log.Lines.add('send rpm: ' + floattostrf(rpm,ffGeneral,15,3	));
  Toothsend('<r'+floattostrf(rpm,ffGeneral,15,3	) +inttostr(stepper.itemindex+1)+ '>',true,false);// max speed
  wait_receive_float(3,rpm);

{  log.Lines.add('enable: ' + stepper.items[stepper.itemindex]);
  Toothsend('<f'+inttostr(stepper.itemindex+1) + '>');//stepper
  wait_receive_int(11,stepper.itemindex+1); not necessary, automatically enabled}

  all_received_string := '';
  log.Lines.add('send onspeed: ' + floattostrf(onspeed,ffGeneral,15,3	));
  Toothsend('<o'+floattostrf(onspeed,ffGeneral,15,3	) + inttostr(stepper.itemindex+1)+'>',true,false);// max speed
  wait_receive_float(2,onspeed);
  all_received_string := '';

  all_received_string := '';
  Toothsend('<k'+'FAULT' + inttostr(stepper.itemindex+1)+'>',true,false);// wait for ready
  log.Lines.add('Wait for ready');
  wait_receive(0,'rdy'); // pic 24 returns ready when completely programmed


  start_time := now;
  timer1.Enabled := true;
  stopbut.enabled := true;
  finally
  testbut.enabled := true;
  end;

end;



procedure TMainform.stopbutClick(Sender: TObject);
begin
  timer1.Enabled := false;
  stopbut.enabled := false;
  Toothsend('<<y'+'8:y' + inttostr(stepper.itemindex+1)+'>',true,false);//reset program
end;


procedure TMainform.command_butClick(Sender: TObject);
begin

  log.Lines.add('send total steps: ' + totsteps.Text);
  kick_in := '<cq'+totsteps.Text+inttostr(stepper.itemindex+1) + '>';
  kick_in_timer := true; // one time kick in the command, next command may only be pushed when kick_in_timer is false.
  start_time := now;

  if not in_timer then  // only enable the timer when not already inside timer routine.
  begin
     stopbut.Enabled := true;
     timer1.Enabled := true;
  end;

end;

procedure TMainform.FormClose(Sender: TObject; var Action: TCloseAction);
begin
  if se.Active then
     se.Active := false;
end;


procedure TMainform.encoder1Click(Sender: TObject);
begin
  encoderset1.enabled := encoder1.enabled;
end;

procedure TMainform.SaveButtonClick(Sender: TObject);
begin
  write_ini;
end;

procedure TMainform.encoder2Click(Sender: TObject);
begin
    encoderset2.enabled := encoder2.enabled;
end;

procedure TMainform.encoder3Click(Sender: TObject);
begin
    encoderset3.enabled := encoder3.enabled;
end;

procedure TMainform.FormActivate(Sender: TObject);
begin
  try
     mainform.se.Active := true;
  except
  end;
end;

procedure TMainform.encoder4Click(Sender: TObject);
begin
  encoderset4.enabled := encoder4.enabled;
end;

end.
